大道至简，勿要脱裤子放屁。
不管安全，不管效率，直接裸奔，反正2^n。

目标：前后端分别运行，前端编写完保存本地后，点击运行qs脚本，然后后端把qs脚本解析成cpp，编译之后输出结果给后端。
所以前端单独编译，后端也单独编译，运行文件也单独编译，这样就不会因为一个东西爆掉就彻底卡死。主要是cpp不支持热编译导致的。
交互接口要约定清楚，数据传输分好几层。
电路数据：前端/本地文件创建/编辑qs脚本，后端解析为结构化电路数据
状态数据：后端根据电路数据进行运算，最终结果保存在本地，前端可以读本地结果，也可以读内存中的中间结果
qs文件数据：保存在本地，前端可以读写qs脚本，后端用parse将其变成一个main中的circuit代码，然后编译成以qs文件名为名的可执行文件，运行途中和后端共享结果变量

中期阶段实现：
1. Shor算法实现
2. 前端运行展示（直接用框架实现？后端怎么处理？）
3. FPGA简单跑跑

过渡计划：
- 笔记本上C++ -> ZYNQ上C++ -> ZYNQ上异构计算
- Qt界面 + Qt WebEngine，实现浏览器访问，在ARM核上跑

考虑联网的运作模式：
1. 直接搭建tcp服务器，前后端tcp数据交换，前端把circuit送回后端，后端把计算结果返回前端（更极端的设计：circuit也在本地处理，前端只传需要计算的数据回后端计算，然后返回结果更新值）
2. qt客户端在电脑上，